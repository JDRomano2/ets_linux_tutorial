# Working with external data volumes: mounting, copying, and file system architectures

This section of the tutorial is perhaps the most important in terms of the work we do in the CDC and Helpline, and the previous chapters can be seen as leading up to the subjects covered on this page.

When you plug an external hard drive, a hard drive from another computer, or any other mass-storage device into a computer, the files on it are not inherently accessible by the Linux operating system that you are using. This is because all Unix-based operating systems have a file structure that looks like a single tree, with ALL files stemming away from one root directory. The external storage device looks like its own tree, so you are not able to interact with it at first. 'Mounting' a hard drive is the process of essentially attaching the external device's root directory to a location on the main file system, so it becomes a part of the single-tree file structure

Back in the old days, when Linux was a good deal younger, all external file systems had to be mounted manually after connecting them to the Linux computer. Now, most installations of Linux are able to recognize when an external file system is attached, and are smart enough to automatically mount it to an appropriate location. However, when the external file system is damaged (such as a dying hard drive) or if you are stuck with a command line interface (which is what this guide assumes!), this automatic mounting often doesn't work.


## Mounting: Locations and naming conventions

Prior to mounting an external volume, it is still visible as a device, listed in the directory `/dev/` (which stands for "devices"). This is, for all intents and purposes, just a label that lets you know that there is something plugged in. If the label attached to the volume is `/dev/sdb1`, you cannot `cd` into that location to view the files on the device, because the label isn't a real directory. Instead, this label is used to specify <i>which</i> external file system you are trying to mount when you use the `mount` command.

The `mount` command is fairly intuitive. Standard syntax is `mount device_label mount_location`. You can pretty much specify any mount location you want, but convention dictates that you <i>should</i> put it in the `/mnt` directory. (Note also that many modern Linux distributions (including Ubuntu) have a `/media` directory. When you insert a device that is automatically mounted, this is the directory in which they will be mounted by Ubuntu. While you can manually mount volumes here, it's a better idea to do it in `/mnt` to avoid confusion.)

Let's walk through a standard mounting scenario. We want to pull some files off of a hard drive, and for whatever reason, the hard drive isn't automatically mounting when we plug it into a USB dock attached to a desktop running Ubuntu. However, since the drive is still working and readable, Ubuntu creates a drive label that you can use to mount it (NOTE: see next section on how to identify a drive's label). Let's say we identified the label as `/dev/sdb1`. We want to mount it in the directory `/mnt/BACKUP`. We can accomplish this with the command `mount /dev/sdb1 /mnt/BACKUP`. Now, to view the files on the drive, we can simply say `cd /mnt/BACKUP/`.


## Mounting: Identifying the drive label of a volume you need to mount manually

Sometimes, identifying the drive label can be tricky, especially since there are often a lot of items in `/dev`. There isn't one "right" way to determine which label corresponds to the device you plugged in, but the two following options are the ones I prefer:

1.) If `fsarchiver` is installed, the command `sudo fsarchiver probe` will list all devices plugged into the computer. The "Device" column shows the label (without the prepended `/dev/`).

2.) Alternatively, just see which entries in `/dev` change when you plug in the device. Run the command `ls -l /dev` without the device plugged in, and run it a second time after plugging in the device. Compare the two lists of files. If the second one contains `sdb` and `sdb1`, while the first one does not, it means that `sdb` is the label for the USB drive you plugged in, and `sdb1` is the label for the first (or only) partition on it. Therefore, use the command `mount /dev/sdb1 /mnt/BACKUP` to mount it.


## Copying: Copying entire volumes

Since mounted volumes preserve their file structure when mounted in Linux, copying the volume is often as simple as copying any other directory recursively (ex., `sudo cp -rv /mnt/source /mnt/destination`). However, there are instances where you <i>can't</i> simply do a single `cp` to copy the contents of a drive. There are numerous utilities that are designed to recover data from a damaged or otherwise inaccessible volume.


#### `fsarchiver`

`fsarchiver` is a utility primarily designed to archive a filesystem in a compressed format (although we mentioned that it can be used with the `probe` command to list drives/volumes, as well). For all intents and purposes, we use it to copy the full contents of a volume to a location on another volume. It is good for copying the contents of HFS+ or NTFS (OS X and NTFS filetypes, respectively), particularly when you want to store them as an archive on a file system of a different type. The syntax structure to archive a volume is `fsarchiver options command archivename filesystem_name`. One example of saving an NTFS filesystem named `my_hard_drive` to an archive named `archive` in the directory `~/Backups` would be: `fsarchiver -v savefs ~/archive ntfs`. There are many different options and commands available to choose from, so I strongly recommend reading the documentation (`man fsarchiver`) to see what is available to you.


#### `dd` and `ddrescue`

`dd` is a utility that will make a bitwise copy (i.e., it copies every single bit exactly as it is in the source - normally, the file gets slightly altered in various ways to make it compatible with the target directory) of a file or multiple files. As such, `dd` is useful for copying files that otherwise cannot be accessed, whether they are corrupt or otherwise non-functional (usually). We recommend that you stay away from `dd`, but know that it is a utility available to technicians with a fair amount of Linux experience (see Travis, Joe R., or Nicholai), and can be rather useful.

`ddrescue` is a utility that adds additional functionality to `dd`s feature set, further optimized to copy files from a damaged filesystem. In the case of disk read errors, `ddrescue` will 'try hard' (as stated by the documentation) to push past these errors. Again, it's not a bad idea to read through the documentation yourself, but ask a lead tech or supervisor before using this. It has the ability to screw things up if used incorrectly.

